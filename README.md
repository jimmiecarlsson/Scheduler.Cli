# Modularity challenge

This is a suggestion generated by Chat GPT to solve a **web project starting as an console project**. 
My goal is to get a clean structure as possible, a way to handle the structure and meanwhile learn 
about modularity. We'll see how it works.

# Scheduler

A simple scheduling application cli built as a **Console App** to start with.  
The structure is modular so the same core logic can later be reused in a Web App.

## Project structure
```
Scheduler.Cli/
  Program.cs
  Domain/        // business rules and models
  Application/   // use cases (e.g. BuildWeekSchedule)
  Infrastructure // simple adapters (e.g. music library)
```

## Design principles
- **Cli** only handles input/output.  
- **Domain** contains all scheduling rules (no overlaps, 24h coverage, studio assignment).  
- **Application** orchestrates use cases (build week, fill gaps with music).  
- **Infrastructure** provides technical helpers (e.g. in-memory music list).  

## Flow (ASCII diagram)
```
Start with:

[Cli (ConsoleApp) UI] → calls → [Application Use Case] → uses → [Domain Rules]
                                            ↘
                                             → [Infrastructure Adapters]

The goal:

[Cli UI]     [Web UI]
       \         /
        \       /
         v     v
      [Application Layer]
        - Orchestration
        - Ports (IMusicLibrary, IScheduleRepository)
              |
              v
         [Domain Layer]
           - Core models & rules
              ^
              |
      [Infrastructure Layer]
        - InMemory / File / Database adapters

```

## Next step
When moving to a Web App, the goal is that the Domain, Application, and Infrastructure folders can be lifted into separate class library projects.  
The logic stays the same — only the presentation layer changes (Console → Web). Fingers crossed :P
