# Scheduler.Web ‚Äì API f√∂r schemal√§ggning

Detta projekt √§r en **C# .NET Web API-applikation** som exponerar endpoints f√∂r att hantera ett veckoschema.  
Projektet √§r byggt utan databas (in-memory) och anv√§nds f√∂r att demonstrera API-design och CRUD-operationer.  

---

## ‚ú® Endpoints

### H√§mta data
- `GET /api/schedule/all` ‚Üí h√§mta hela schemat (alla dagar och block)  
- `GET /api/schedule/today` ‚Üí h√§mta dagens schema  
- `GET /api/schedule/week` ‚Üí h√§mta de kommande 7 dagarna  
- `GET /api/schedule/{id}` ‚Üí h√§mta detaljer f√∂r ett specifikt block  

### Hantera block
- `POST /api/schedule/block` ‚Üí skapa nytt block  
- `PUT /api/schedule/block/{id}` ‚Üí uppdatera ett block (√§ndra tid, titel, studio)  
- `DELETE /api/schedule/block/{id}` ‚Üí ta bort ett block  

### Hantera presenters
- `POST /api/schedule/block/{id}/presenter` ‚Üí l√§gg till en presenter  
- `DELETE /api/schedule/block/{id}/presenter/{presenterId}` ‚Üí ta bort en presenter  

### Hantera guests
- `POST /api/schedule/block/{id}/guest` ‚Üí l√§gg till en guest  
- `DELETE /api/schedule/block/{id}/guest/{guestId}` ‚Üí ta bort en guest  

---

## üìå Exempelanrop

**POST /api/schedule/block**  
```json
{
  "date": "2025-09-23",
  "startTime": "10:00",
  "endTime": "11:00",
  "title": "Morgonm√∂te",
  "studio": "Studio1"
}
```

**Svar (201 Created):**
```json
{
  "id": 7,
  "date": "2025-09-23",
  "startTime": "10:00",
  "endTime": "11:00",
  "title": "Morgonm√∂te",
  "studio": "Studio1",
  "presenters": [],
  "guests": []
}
```

---

## ‚öôÔ∏è Teknisk info
- .NET 9 (ASP.NET Core Web API, Controllers)  
- In-memory lagring (ingen databas)  
- OpenAPI/Scalar anv√§nds f√∂r test av endpoints  

---

# Modularity challenge as a limitation

This is a suggestion generated by ChatGPT to solve a **web project starting as a console project**.  
My goal is to get a clean structure as possible, a way to handle the structure and meanwhile learn about modularity. We'll see how it works.  

## Scheduler

A simple scheduling application cli built as a **Console App** to start with.  
The structure is modular so the same core logic can later be reused in a Web App.  

### Project structure
```
Scheduler.Cli/
  Program.cs
  Domain/        // business rules and models
  Application/   // use cases (e.g. BuildWeekSchedule)
  Infrastructure // simple adapters (e.g. music library)
```

### Design principles
- **Cli** only handles input/output.  
- **Domain** contains all scheduling rules (no overlaps, 24h coverage, studio assignment).  
- **Application** orchestrates use cases (build week, fill gaps with music).  
- **Infrastructure** provides technical helpers (e.g. in-memory music list).  

### Flow (ASCII diagram)
```
Start with:

[Cli (ConsoleApp) UI] ‚Üí calls ‚Üí [Application Use Case] ‚Üí uses ‚Üí [Domain Rules]
                                            ‚Üò
                                             ‚Üí [Infrastructure Adapters]

The goal:

[Cli UI]     [Web UI]
       \         /
        \       /
         v     v
      [Application Layer]
        - Orchestration
        - Ports (IMusicLibrary, IScheduleRepository)
              |
              v
         [Domain Layer]
           - Core models & rules
              ^
              |
      [Infrastructure Layer]
        - InMemory / File / Database adapters
```

### Next step
When moving to a Web App, the goal is that the Domain, Application, and Infrastructure folders can be lifted into separate class library projects.  
The logic stays the same ‚Äî only the presentation layer changes (Console ‚Üí Web). Fingers crossed :P  
