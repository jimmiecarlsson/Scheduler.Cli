# Scheduler.Web ‚Äì API f√∂r schemal√§ggning

Detta projekt √§r en **C# .NET Web API-applikation** som exponerar endpoints f√∂r att hantera ett veckoschema.  
Projektet √§r byggt utan databas (in-memory) och anv√§nds f√∂r att demonstrera API-design och CRUD-operationer.  

---

## ‚ú® Endpoints

### H√§mta data
- `GET /api/schedule/all` ‚Üí h√§mta hela schemat (alla dagar och block)  
- `GET /api/schedule/today` ‚Üí h√§mta dagens schema  
- `GET /api/schedule/week` ‚Üí h√§mta de kommande 7 dagarna  
- `GET /api/schedule/{id}` ‚Üí h√§mta detaljer f√∂r ett specifikt block  

### Hantera block
- `POST /api/schedule/block` ‚Üí skapa nytt block  
- `PUT /api/schedule/block/{id}` ‚Üí uppdatera ett block (√§ndra tid, titel, studio)  
- `DELETE /api/schedule/block/{id}` ‚Üí ta bort ett block  

### Hantera presenters
- `POST /api/schedule/block/{id}/presenter` ‚Üí l√§gg till en presenter  
- `DELETE /api/schedule/block/{id}/presenter/{presenterId}` ‚Üí ta bort en presenter  

### Hantera guests
- `POST /api/schedule/block/{id}/guest` ‚Üí l√§gg till en guest  
- `DELETE /api/schedule/block/{id}/guest/{guestId}` ‚Üí ta bort en guest  

---

## üìå Exempelanrop

**POST /api/schedule/block**  
```json
{
  "date": "2025-09-23",
  "startTime": "10:00",
  "endTime": "11:00",
  "title": "Morgonm√∂te",
  "studio": "Studio1"
}
```

**Svar (201 Created):**
```json
{
  "id": 7,
  "date": "2025-09-23",
  "startTime": "10:00",
  "endTime": "11:00",
  "title": "Morgonm√∂te",
  "studio": "Studio1",
  "presenters": [],
  "guests": []
}
```

---

## ‚öôÔ∏è Teknisk info
- .NET 9 (ASP.NET Core Web API, Controllers)  
- In-memory lagring (ingen databas)  
- API:et exponerar en OpenAPI-specifikation och testas via Scalar (inkluderat i projektet).

---

# Modularity challenge as a limitation

This is a suggestion generated by ChatGPT to solve a **web project starting as a console project**.  
My goal is to get a clean structure as possible, a way to handle the structure and meanwhile learn about modularity. We'll see how it works.  

## Scheduler

A simple scheduling application cli built as a **Console App** to start with.  
The structure is modular so the same core logic can later be reused in a Web App.  

### Project structure
```
Scheduler.Cli/
  Program.cs
  Domain/        // business rules and models
  Application/   // use cases (e.g. BuildWeekSchedule)
  Infrastructure // simple adapters (e.g. music library)
```

### Design principles
- **Cli** only handles input/output.  
- **Domain** contains all scheduling rules (no overlaps, 24h coverage, studio assignment).  
- **Application** orchestrates use cases (build week, fill gaps with music).  
- **Infrastructure** provides technical helpers (e.g. in-memory music list).  

### Flow (ASCII diagram)
```
Start with:

[Cli (ConsoleApp) UI] ‚Üí calls ‚Üí [Application Use Case] ‚Üí uses ‚Üí [Domain Rules]
                                            ‚Üò
                                             ‚Üí [Infrastructure Adapters]

The goal:

[Cli UI]     [Web UI]
       \         /
        \       /
         v     v
      [Application Layer]
        - Orchestration
        - Ports (IMusicLibrary, IScheduleRepository)
              |
              v
         [Domain Layer]
           - Core models & rules
              ^
              |
      [Infrastructure Layer]
        - InMemory / File / Database adapters
```

### Next step
When moving to a Web App, the goal is that the Domain, Application, and Infrastructure folders can be lifted into separate class library projects.  
The logic stays the same ‚Äî only the presentation layer changes (Console ‚Üí Web). Fingers crossed :P

---

# üß± Scheduler.Web ‚Äì API for Scheduling (v2)

This project has evolved from an in-memory demo API into a **fully persistent web service** built with  
**.NET 9**, **Entity Framework Core**, and a **Clean Architecture** structure.

---

## üöÄ What‚Äôs New in Version 2

- ‚úÖ **SQLite database** via Entity Framework Core  
- ‚úÖ **Full CRUD** persistence for `ScheduleBlocks`, `Presenters`, and `Guests`  
- ‚úÖ **PUT / DELETE** now save changes directly to the database  
- ‚úÖ **Validation logic** (no overlapping time ranges) enforced at domain level  
- ‚úÖ **OpenAPI/Scalar** documentation works with live data  
- ‚úÖ **Separation of layers**: *Domain / Application / Infrastructure / Web*  
- ‚úÖ **Cascading deletes** between `ScheduleBlock` ‚Üí `Presenters` / `Guests`  
- ‚úÖ **No more in-memory seeding** ‚Äì database state persists between runs  

---

## üìÇ Project Structure

```
Scheduler.Domain/        // Core business rules and entities
Scheduler.Application/   // Use-case orchestration (DTOs, services)
Scheduler.Infrastructure // EF Core DbContext and database setup
Scheduler.Web/           // ASP.NET Core Web API (Controllers + Scalar)
```

Each layer has a single responsibility:
- **Domain** ‚Äì rules, value objects (`TimeOfDayRange`, `Studio`), and entities (`ScheduleDay`, `ScheduleBlock`, `Presenter`, `Guest`)
- **Application** ‚Äì orchestrates logic and mappings
- **Infrastructure** ‚Äì connects EF Core to SQLite
- **Web** ‚Äì exposes endpoints and handles I/O

---

## ‚öôÔ∏è Technical stack

- **.NET 9** (ASP.NET Core Web API)  
- **Entity Framework Core 9** with **SQLite**  
- **OpenAPI / Scalar UI** for documentation  
- **Dependency Injection** and scoped DbContext  

---

## üß© Endpoints (current)

| Purpose | Method | Route |
|----------|---------|-------|
| Get all schedule data | GET | `/api/schedule/all` |
| Get today‚Äôs schedule | GET | `/api/schedule/today` |
| Get upcoming week | GET | `/api/schedule/week` |
| Get block by id | GET | `/api/schedule/{id}` |
| Create block | POST | `/api/schedule/block` |
| Update block | PUT | `/api/schedule/block/{id}` |
| Delete block | DELETE | `/api/schedule/block/{id}` |
| Add presenter | POST | `/api/schedule/block/{id}/presenter` |
| Delete presenter | DELETE | `/api/schedule/block/{id}/presenter/{presenterId}` |
| Add guest | POST | `/api/schedule/block/{id}/guest` |
| Delete guest | DELETE | `/api/schedule/block/{id}/guest/{guestId}` |

---

## üìñ Example ‚Äì Create Block

**POST /api/schedule/block**

```json
{
  "date": "2025-10-08",
  "startTime": "10:00",
  "endTime": "12:00",
  "title": "EF Test",
  "studio": "Studio1"
}
```

**Response (201 Created)**  
```json
{
  "id": 5,
  "date": "2025-10-08",
  "startTime": "10:00",
  "endTime": "12:00",
  "title": "EF Test",
  "studio": "Studio1"
}
```

---

## üß† Design Reflection

Migrating from an in-memory prototype to a real database clearly showed the strength of the architecture:
- Controllers stayed small and clean  
- No logic duplication  
- Each layer could evolve independently  
- EF Core handled persistence transparently